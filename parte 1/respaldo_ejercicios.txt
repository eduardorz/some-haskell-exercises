
--      1 . Programar las siguientes funciones 

--      a) esCero :: Int -> Bool, que verifica si un entero es igual a 0.

esCero :: Int -> Bool
esCero x | (x == 0) = True
         | (x /= 0) = False

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> esCero 0
--    True

--[2]
--    ghci> esCero 5
--    False

--[3]
--    ghci> esCero (-3)
--    False


--      b) esPositivo :: Int -> Bool, que verifica si un entero es estrictamente mayor a 0.

esPositivo :: Int -> Bool
esPositivo x | (x >  0) = True
             | (x <= 0) = False

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> esPositivo 5
--    True

--[2]
--    ghci> esPositivo (-3)
--    False


--      c) esVocal :: Char -> Bool, que verifica si un caracter es una vocal en minuscula.

esVocal :: Char -> Bool
esVocal a | (a >= 97 && a <= 122) = True
          | otherwise             = False

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> esVocal 'a'
--    True

--[2]
--    ghci> esVocal 'E'
--    False


--      d) valorAbsoluto :: Int -> Int, que devuelve el valor absoluto de un entero ingresado.

valorAbsoluto :: Int -> Int
valorAbsoluto n
    | n < 0 = -n
    | otherwise = n
    
-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> valorAbsoluto 5
--    5

--[2]
--    ghci> valorAbsoluto (-8)
--    8



--      2 . Programar las siguientes funciones usando recursion o composicion:

--      a) paratodo :: [Bool] -> Bool, que verifica que todos los elementos de una lista sean True.

paratodo :: [Bool] -> Bool
paratodo [ ] = True
paratodo (x:xs) | (x == True)  = paratodo xs
                | (x == False) = False

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> let lista1 = [True, True, True, True]
--    ghci> paratodo lista1
--    True

--[2]
--    ghci> let lista2 = [True, False, True, True]
--    ghci> paratodo lista2
--    False


--      b) sumatoria :: [Int] -> Int, que calcula la suma de todos los elementos de una lista de enteros.

sumatoria :: [Int] -> Int
sumatoria [ ] = 0
sumatoria (x:xs) = x + sumatoria xs

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> let lista1 = [1, 2, 3, 4, 5]
--    ghci> sumatoria lista1
--    15

--[2]
--    ghci> let lista2 = []
--    ghci> sumatoria lista2
--    0


--      c) productoria :: [Int] -> Int, que calcula el producto de todos los elementos de la lista de enteros.

productoria :: [Int] -> Int
productoria [ ] = 1
productoria (x:xs) = x * productoria xs

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> let lista1 = [2, 3, 4, 5]
--    ghci> productoria lista1
--    120

--[2]
--    ghci> let lista4 = [42]
--    ghci> productoria lista4
--    42


--      d) factorial :: Int -> Int, que toma un numero n y calcula n!.

factorial :: Int -> Int
factorial 0 = 1
factorial x = x * factorial (x-1)

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> factorial 5
--    120

--[2]
--    ghci> factorial 7
--    5040


--      e) Utilizar la funcion sumatoria para definir, promedio :: [Int] -> Int, 
--         que toma una lista de numeros no vacia y calcula el valor promedio (truncado, usando division entera).

promedio :: [Int] -> Int
promedio [ ] = 0
promedio xs = div (sumatoria xs) (length xs)

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> let lista1 = [10, 20, 30, 40, 50]
--    ghci> div (sum lista1) (length lista1)
--    30

--[2]
--    ghci> let lista5 = [1.5, 2.5, 3.5, 4.5]
--    ghci> div (round (sum lista5)) (length lista5)
--    2



--      3 . Programar la funcion pertenece :: Int -> [Int] -> Bool, que verifica si un numero se encuentra en una lista.

pertenece :: Int -> [Int] -> Bool
pertenece n [ ] = False
pertenece n (x:xs) | n == x    = True
                   | otherwise = pertenece n xs

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> pertenece 8 [1, 2, 3, 4, 5, 6]
--    False

--[2]
--    ghci> pertenece 3 []
--    False



--      4 . Programar las siguientes funciones que implementan los cuantificadores generales. 
--          Notar que el segundo parametro de cada funcion, es otra funcion!

--      a) paratodo’ :: [a] -> (a -> Bool) -> Bool, dada una lista xs de tipo [a] y un predicado t :: a -> Bool, 
--         determina si todos los elementos de xs satisfacen el predicado t.

paraTodo' :: [a] -> (a -> Bool) -> Bool
paraTodo' [ ] p = True
paraTodo' (x:xs) p | (p x == True)  = paraTodo' xs p 
                   | (p x == False) = False

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> paraTodo' [2, 4, 6, 8] even
--    True

--[2]
--    ghci> paraTodo' [7, 9, 6, 8] (\x -> x > 5)
--    False

                   
--      b) existe’ :: [a] -> (a -> Bool) -> Bool, dada una lista xs de tipo [a] y un predicado t :: a -> Bool, 
--         determina si algun elemento de xs satisface el predicado t.

existe' :: [a] -> (a -> Bool) -> Bool
existe' [ ] p = False
existe' (x:xs) p | (p x == True)  = True
                 | (p x == False) = existe' xs p

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> existe' [5, 8, 12, 15, 6, 3] (\x -> x > 10)
--    True

--[2]
--    ghci> existe' [2, 4, 6, 8, -3, 10] (\x -> x < 0)
--    True


--      c) sumatoria’ :: [a] -> (a -> Int) -> Int, dada una lista xs de tipo [a] y una funcion t :: a -> Int 
--         (toma elementos de tipo a y devuelve enteros), calcula la suma de los valores que resultan de la 
--         aplicacion de t a los elementos de xs.

sumatoria' :: [a] -> (a -> Int) -> Int
sumatoria' [ ] t = 0
sumatoria' (x:xs) t = (t x) + sumatoria' xs t

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> sumatoria' [1, 3, 5, 7, 9] (\x -> x * x * x)
--    1575

--[2]
--    ghci> sumatoria' [1..10] id
--    55


--      d) productoria’ :: [a] -> (a -> Int) -> Int, dada una lista de xs de tipo [a] y una funcion t :: a -> Int, 
--         calcula el producto de los valores que resultan de la aplicacion de t a los elementos de xs.

productoria' :: [a] -> (a -> Int) -> Int
productoria' [ ] t = 1
productoria' (x:xs) t = (t x) * productoria' xs t

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> productoria' [1..5] id
--    120

--[2]
--    ghci> productoria' [-3, 5, -2, 7, -1] (\x -> abs x)
--    210


--      5 . Definir nuevamente la funcion paratodo, pero esta vez usando la funcion paratodo’ 
--          (sin recursion ni analisis por casos!).

paraTodo'' :: [Bool] -> Bool
paraTodo'' xs = paraTodo' xs id

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> paraTodo'' [True, True, True, True]
--    True

--[2]
--    ghci> paraTodo'' [True, False, True, True]
--    False

--[3]
--    ghci> paraTodo'' [False, False, False, False]
--    False

--      6 . Utilizando las funciones del ejercicio 4, programar las siguientes funciones por composicion, 
--          sin usar recursion ni analisis por casos.


--      a) todosPares :: [Int] -> Bool verifica que todos los numeros de una lista sean pares.

todosPares :: [Int] -> Bool
todosPares (x:xs) = paraTodo' xs even

--  EJEMPLOS DE EJECUCION

--[1]
--    ghci> todosPares [2, 4, 6, 8, 10]
--    True

--[2]
--    ghci> todosPares [1, 3, 5, 7, 9]
--    False


--      b) hayMultiplo :: Int -> [Int] -> Bool verifica si existe algun numero dentro del 
--         segundo parametro que sea multiplo del primer parametro.

hayMultiplo :: Int -> [Int] -> Bool
hayMultiplo a xs = existe' xs (\x -> mod x a == 0)

--  EJEMPLOS DE EJECUCION

--[1]
--    ghci> hayMultiplo 4 [2, 4, 5, 6, 8]
--    True

--[2]
--    ghci> hayMultiplo 5 [1, 3, 7, 9, 11]
--    False


--      c) sumaCuadrados :: Int -> Int, dado un numero no negativo n, calcula la suma de los primeros n cuadrados

sumaCuadrados :: Int -> Int
sumaCuadrados n = sumatoria' [1..n] (\x -> x * x)

--  EJEMPLOS DE EJECUCION

--[1]
--    ghci> sumaCuadrados 10
--    385

--[2]
--    ghci> sumaCuadrados 3
--    14


--      d) Programar la fucion existeDivisor :: Int-> [Int] -> Bool, que dado en entero n y una lista ls , 
--         devuelve True si y solo si, existe algun elemento en ls que divida a n.

existeDivisor :: Int -> [Int] -> Bool
existeDivisor n [] = False
existeDivisor n ls = existe' ls (\x -> n `mod` x == 0)

--  EJEMPLOS DE EJECUCION

--[1]
--    ghci> existeDivisor 12 [1, 2, 3, 4, 5, 6]
--    True

--[2]
--    ghci> existeDivisor 17 [2, 3, 5, 7, 11, 13, 19]
--    False


--      e) Utilizando la funcion del apartado anterior, definir la funcion esPrimo:: Int -> Bool, 
--         que dado un entero n, devuelve True si y solo si n es primo.

esPrimo :: Int -> Bool
esPrimo n | n <= 1 = False
          | otherwise = not (existeDivisor n [2..n-1])

--  EJEMPLOS DE EJECUCION

--[1]
--    ghci> esPrimo 12
--    False

--[2]
--    ghci> esPrimo 19
--    True


--      f) ¿Se te ocurre como redefinir factorial (ej. 2d) para evitar usar recursion?

factorial :: Integer -> Integer
factorial n = foldr (*) 1 [1..n]

--  EJEMPLOS DE EJECUCION

--[1]
--    ghci> factorial 10
--    3628800

--[2]
--    ghci> factorial 3
--    6


--      g) Programar la funcion multiplicaPrimos :: [Int] -> Int que calcula el producto de 
--         todos los numeros primos de una lista.

multiplicaPrimos :: [Int] -> Int
multiplicaPrimos xs = productoria' (filter esPrimo xs) id

--  EJEMPLOS DE EJECUCION

--[1]
--    ghci> multiplicaPrimos [4, 6, 8, 9]
--    1

--[2]
--    ghci> multiplicaPrimos [2, 4, 5, 7, 10]
--    70


--      h) Programar la funcion esFib :: Int -> Bool, que dado un entero n, devuelve True si y solo si 
--         n está en la sucesión de Fibonacci. 
--         Ayuda: Realizar una funcion auxiliar fib :: Int -> Int que dado un n devuelva el 
--         n-ésimo elemento de la sucesión.

fib :: Int -> Int
fib n | (n <= 1)    = n
      | (otherwise) = fib (n - 1) + fib (n - 2)

esFib :: Int -> Bool
esFib n = pertenece n (map fib [1..(n+1)])

--  EJEMPLOS DE EJECUCION

--[1]
--    ghci> esFib 8
--    True

--[2]
--    ghci> esFib 5
--    True

--[3]
--    ghci> esFib 10
--    False


--      i) Utilizando la funcion del apartado anterior, definir la funcion todosFib :: [Int] -> Bool 
--      que dada una lista xs de enteros, devuelva si todos los elementos de la lista pertenecen (o no) 
--      a la sucesion de Fibonacci.

todosFib :: [Int] -> Bool
todosFib [ ] = True
todosFib (x:xs) = esFib x && todosFib xs

--  EJEMPLOS DE EJECUCION

--[1]
--    ghci> todosFib [1, 1, 2, 3, 5, 8]
--    True

--[2]
--    ghci> todosFib [0, 1, 1, 2, 3, 5, 8]
--    False


--      7 . Indagar en Hoogle sobre las funciones map y filter.
--          También podes consultar su tipo en ghci con el comando :t

--          ¿Que hacen estas funciones?

--La funcion map se encarga de aplicarle una funcion dada a cada elemento de una lista xs

--La funcion filter es una funcion de orden superior que se encarga de filtrar elementos de una lista mediante una condicion especifica


--          ¿A que equivale la expresion map succ [1, -4, 6, 2, -8], donde succ n = n+1?

-- [2, -3, 7, 3, -7]


--           ¿Y la expresion filter esPositivo [1, -4, 6, 2, -8]?

-- [1, 6, 2]



--      8 . Programar una funcion que dada una lista de numeros xs, 
--          devuelve la lista que resulta de duplicar cada valor de xs.

--      a) definirla usando recursion

duplicar :: [Int] -> [Int]
duplicar [ ] = [ ]
duplicar (x:xs) = (x*2) : duplicar xs

--   EJEMPLOS DE EJECUCION

--[1]
--    ghci> duplicar [1, 2, 3, 4, 5]
--    [2,4,6,8,10]

--[2]
--    ghci> duplicar [-1, -2, -3, -4, -5]
--    [-2,-4,-6,-8,-10]

--[3]
--    ghci> duplicar [0, 2, 0, 4, 0]
--    [0,4,0,8,0]


--      b) definirla usando la funcion map

duplicar :: [Int] -> [Int]
duplicar (x:xs) = map (*2) xs

--   EJEMPLOS DE EJECUCION

--[1]
--    ghci> duplicar [1, 2, 3, 4, 5]
--    [4, 6, 8, 10]

--[2]
--    ghci> duplicar [2, 3, 5, 7, 11]
--    [6, 10, 14, 22]



--      9 . Programar una funcion que dada una lista de numeros xs, calcula una lista que tiene 
--          como elementos aquellos numeros de xs que son primos.

--      a)  definirla usando recursion

listaPrimos :: [Int] -> [Int]
listaPrimos [ ] = [ ]
listaPrimos (x:xs) | esPrimo x = x : listaPrimos xs 
                   | otherwise = listaPrimos xs

--      EJEMPLOS DE EJECUCION

--[1]
--    ghci> listaPrimos []
--    []

--[2]
--    ghci> listaPrimos [-1, -2, -3, -4, -5, -6]
--    []

--[3]
--    ghci> listaPrimos [2, 3, 4, 5, 6, 7, 8, 9, 10]
--    [2,3,5,7]


--      b)  definirla usando la funcion filter

listaPrimos :: [Int] -> [Int]
listaPrimos xs = filter esPrimo xs

--  EJEMPLOS DE EJECUCION

--[1]
--    ghci> listaPrimos [2, 3, 4, 5, 6, 7, 8, 9, 10]
--    [2,3,5,7]

--[2]
--    ghci> listaPrimos [11, 13, 17, 19]
--    [11,13,17,19]

--[3]
--    ghci> listaPrimos []
--    []


--      c)  revisar tu definicion del ejercicio 6g ¿como podes mejorarla?

multiplicaPrimos :: [Int] -> Int
multiplicaPrimos xs = productoria' (listaPrimos xs) id

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> multiplicaPrimos []
--    1

--[2]
--    ghci> multiplicaPrimos [2, 3, 4, 5, 6, 7, 8, 9, 10]
--    210

--[3]
--    ghci> multiplicaPrimos [11, 13, 17, 19]
--    49377



-- 10 . La funcion primIgualesA toma un valor y una lista, y calcula el tramo inicial mas largo de la lista cuyos
--      elementos son iguales a ese valor. Por ejemplo:

--         primIgualesA 3 [3,3,4,1] = [3,3]
--         primIgualesA 3 [4,3,3,4,1] = []
--         primIgualesA 3 [] = []
--         primIgualesA ’a’ "aaadaa" = "aaa"

--    a) Programar primIgualesA por recursion.

primIgualesA :: Eq a => a -> [a] -> [a]
primIgualesA val [] = []  
primIgualesA val (x:xs)
    | val == x = x : primIgualesA val xs  
    | otherwise = []  

--  EJEMPLOS DE EJECUCION

--[1]
--   ghci> primIgualesA 'b' "abcdeabc"
--   ""

--[2]
--   ghci> primIgualesA 2 [2,2,2,3,3,3,2,2]
--   [2,2,2]


--    b) Programar nuevamente la funcion utilizando takeWhile.

primIgualesA :: Eq a => a -> [a] -> [a]
primIgualesA val [ ] = [ ]
primIgualesA val xs = takewhile (==val) xs   
    
--  EJEMPLO DE EJECUCION

--[1]
--    ghci> let lista1 = "aaadaa"
--    ghci> primIgualesA 'a' lista1
--    "aaa"

--[2]
--    ghci> let lista2 = [3,3,4,1,3,3,3,2]
--    ghci> primIgualesA 3 lista2
--    [3,3]



-- 11 .  La funcion primIguales toma una lista y devuelve el mayor tramo inicial de la lista cuyos
--       elementos son todos iguales entre si. Por ejemplo:

--         primIguales [3,3,4,1] = [3,3]
--         primIguales [4,3,3,4,1] = [4]
--         primIguales [] = []
--         primIguales "aaadaa" = "aaa"

--    a) Programar primIguales por recursion.

primIguales :: Eq a => [a] -> [a]
primIguales [] = []  
primIguales [x] = [x]  
primIguales (x:y:ys)
    | x == y = x : primIguales (y:ys)  
    | otherwise = [x]  

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> primIguales [3,3,4,1]
--    [3,3]

--[2]
--    ghci> primIguales "xyzabcde"
--    "x"


--    b) Usar cualquier version de primIgualesA para programar primIguales. 
--       Esta permitido dividir en casos, pero no usar recursion.

primIguales :: Eq a => [a] -> [a]
primIguales [] = [] 
primIguales xs = primIgualesA (head xs) xs

-- EJEMPLOS DE EJECUCION

--[1]
--    ghci> primIguales "abcabc"
--    "a"

--[2]
--    ghci> primIguales [5,5,5,5]
--    [5,5,5,5]

